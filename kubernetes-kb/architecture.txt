=======================
KUBERNETES ARCHITECTURE
=======================
https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186

=======
MASTER
=======
https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186

Master runs the following:
- API Server - kube-apiserver - core component
- Scheduler - kube-scheduler - core component
- Controller Manager - kube-controller-manager - core component
- ETCD - etcd - - core component - image gcr.io/google_containers/etcd-amd64 
- kube-proxy - core component - 
- kube-addon-manager - additional component
Note: ETCD can be on the master itself or on a different machine

ETCD
- Stores cluster configuration information and state of the cluster, pods etc
- Leader, follower, candidate
- Consensus by Raft algorithm - https://raft.github.io/raft.pdf
- ETCDCTL command - add/modify/delete keys, verify cluster health, add/remove etcd nodes, generate DB snapshots for backups
- 'watch' feature notifies watchers like apiserver upon changes to keys
- Play with 5 node cluster here http://play.etcd.io

API SERVER
- Main management point
- Only component that talks to ETCD
- Watches for new pods, changes to pods, changes to keys ... (watch mechanism)
- Authenticates and authorizes - all API clients shuould be authenticated and authorized

CONTROLLER MANAGER
- Watches state of cluster - via watch feature
- Makes necessary changes to achieve desired state upon notification
- Shipped with Kubernetes - replication controller, endpoints controller, namespace controller
- Creates namespaces and lifecycles them
- Also, lifecycle functions such as namespace creation and lifecycle, event garbage collection, 
  terminated-pod garbage collection, cascading-deletion garbage collection, node garbage collection, etc.

SCHEDULER
- Schedules pods on nodes with available resources
- After scheduling is done, kubelet will create the pod in that node

WHEN A POD IS CREATED
kubectl writes to the API Server.
API Server validates the request and persists it to etcd.
etcd notifies back the API Server.
API Server invokes the Scheduler.
Scheduler decides where to run the pod on and return that to the API Server.
API Server persists it to etcd.
etcd notifies back the API Server.
API Server invokes the Kubelet in the corresponding node.
Kubelet talks to the Docker daemon using the API over the Docker socket to create the container.
Kubelet updates the pod status to the API Server.
API Server persists the new state in etcd.

================
NODES (WORKERS)
================
KUBE PROXY
https://snapcraft.io/kube-proxy
https://kubernetes.io/docs/reference/command-line-tools-reference/kube-proxy/
- has all settings also

Kubernetes network proxy runs on each node.
The Kubernetes network proxy runs on each node. 
This reflects services as defined in the Kubernetes API on each node and can do simple TCP,UDP stream forwarding 
or round robin TCP,UDP forwarding across a set of backends. Service cluster ips and ports are currently 
found through Docker-links-compatible environment variables specifying ports opened by the service proxy. 
There is an optional addon that provides cluster DNS for these cluster IPs. The user must create a service 
with the apiserver API to configure the proxy.
